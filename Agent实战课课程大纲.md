# Agent实战课课程大纲

> 面向大模型技术学习者和Agent应用开发者的完整实战课程

## 课程概述

本课程基于LangGraph和Langfuse技术栈，为学习者提供从基础到高级的Agent开发完整路径。课程严格按照现有代码结构设计，每个章节都对应具体的实验代码，确保理论与实践紧密结合。

### 课程特色
- **🎯 代码驱动**：每个章节都对应具体的Jupyter Notebook代码
- **📚 理实结合**：理论视频+实验操作，双重保障学习效果
- **🔧 可视化调试**：集成LangGraph Studio，支持图形化开发调试
- **📊 完整评估**：基于Langfuse的Agent评估和监控体系
- **🚀 生产就绪**：涵盖从开发到部署的完整技术栈

### 技术栈
- **核心框架**：LangGraph + LangChain
- **评估工具**：Langfuse
- **开发语言**：Python 3.11+
- **可视化**：LangGraph Studio
- **部署**：Docker + Redis + PostgreSQL

---

## 课程章节表格大纲

| 序号 | 课程标题 | 是否实操 | 内容 |
| ---- | -------- | -------- | ---- |
| **第一章：Agent基础入门** | | | |
| 1 | 3分钟了解Agent与LangGraph | | 1、什么是Agent？Agent vs 传统程序架构对比<br/>2、LangGraph核心设计理念：精确性与控制力<br/>3、聊天模型（Chat Models）基础概念<br/>4、LangGraph生态系统介绍<br/>5、快速上手：第一个LangGraph程序<br/>6、社区资源（官方文档、GitHub、学习资源） |
|  | **对应代码：** `0-Introduce/basics.ipynb` | | **算力消耗：** OpenAI API调用~10-20次（约$0.01-0.03） |
| 实操 | Agent开发环境搭建 | 实操 | 1、Python 3.11+环境配置<br/>2、依赖包安装和版本管理<br/>3、API密钥配置（OpenAI、Langfuse等）<br/>4、LangGraph Studio安装和配置<br/>5、Jupyter Notebook环境设置<br/>6、常见环境问题排查 |
| 2 | 简单图构建实战 | 实操 | 1、StateGraph核心概念详解<br/>2、节点（Node）、边（Edge）、状态（State）<br/>3、条件路由的设计原理<br/>4、图的编译和执行流程<br/>5、构建3节点简单图<br/>6、图可视化和调试技巧 |
|  | **对应代码：** `1-Base/01-simple-graph.ipynb` | | **算力消耗：** OpenAI API调用~5-10次（约$0.005-0.015） |
| 3 | 基础Agent开发 | 实操 | 1、Agent vs Chain的区别<br/>2、工具调用机制深入解析<br/>3、ReAct模式原理与实现<br/>4、错误处理策略<br/>5、构建基础聊天机器人<br/>6、性能监控和优化 |
|  | **对应代码：** `1-Base/agent.ipynb`, `1-Base/chain.ipynb` | | **算力消耗：** OpenAI API调用~20-30次（约$0.03-0.05） |
| **第二章：状态管理与内存系统** | | | |
| 4 | 状态模式设计 | 实操 | 1、复杂状态模式设计原则<br/>2、类型化状态的优势<br/>3、多模式状态管理策略<br/>4、状态验证和错误处理<br/>5、自定义状态模式实现<br/>6、复杂数据结构处理 |
|  | **对应代码：** `2-StateAndMemory/state-schema.ipynb`, `multiple-schemas.ipynb` | | **算力消耗：** OpenAI API调用~15-25次（约$0.02-0.04） |
| 5 | 状态缩减器与消息管理 | 实操 | 1、状态缩减器设计原理<br/>2、消息过滤和修剪策略<br/>3、内存优化技术<br/>4、长对话处理方案<br/>5、自定义状态缩减器<br/>6、过滤策略实现 |
|  | **对应代码：** `2-StateAndMemory/state-reducers.ipynb`, `trim-filter-messages.ipynb` | | **算力消耗：** OpenAI API调用~10-20次（约$0.015-0.03） |
| 6 | 外部存储与持久化 | 实操 | 1、检查点器（Checkpointer）概念<br/>2、SQLite vs PostgreSQL选择<br/>3、对话摘要技术<br/>4、数据持久化策略<br/>5、SQLite检查点器配置<br/>6、持久化性能测试 |
|  | **对应代码：** `2-StateAndMemory/chatbot-external-memory.ipynb`, `chatbot-summarization.ipynb` | | **算力消耗：** OpenAI API调用~25-35次（约$0.04-0.06） |
| **第三章：人机交互系统** | | | |
| 7 | 断点与调试机制 | 实操 | 1、Human-in-the-Loop设计原理<br/>2、断点机制实现<br/>3、动态断点控制<br/>4、审批流程设计<br/>5、静态断点设置<br/>6、用户交互界面开发 |
|  | **对应代码：** `3-HumanInTheLoop/breakpoints.ipynb`, `dynamic-breakpoints.ipynb` | | **算力消耗：** OpenAI API调用~15-20次（约$0.02-0.035） |
| 8 | 状态编辑与反馈 | 实操 | 1、状态编辑机制<br/>2、人工反馈集成<br/>3、状态回滚技术<br/>4、用户体验设计<br/>5、反馈收集机制<br/>6、状态同步处理 |
|  | **对应代码：** `3-HumanInTheLoop/edit-state-human-feedback.ipynb` | | **算力消耗：** OpenAI API调用~10-15次（约$0.015-0.025） |
| 9 | 流式处理与时间旅行 | 实操 | 1、流式中断原理<br/>2、时间旅行调试技术<br/>3、状态快照管理<br/>4、并发处理策略<br/>5、流式中断实现<br/>6、并发控制测试 |
|  | **对应代码：** `3-HumanInTheLoop/streaming-interruption.ipynb`, `time-travel.ipynb` | | **算力消耗：** OpenAI API调用~20-25次（约$0.03-0.045） |
| **第四章：高级Agent开发** | | | |
| 10 | 并行执行与性能优化 | 实操 | 1、并行节点设计原理<br/>2、异步执行模式<br/>3、性能瓶颈识别<br/>4、资源调度策略<br/>5、并行节点实现<br/>6、性能基准测试 |
|  | **对应代码：** `4-BuildYourAssiant/parallelization.ipynb` | | **算力消耗：** OpenAI API调用~30-40次（约$0.05-0.07） |
| 11 | Map-Reduce模式 | 实操 | 1、Map-Reduce设计模式<br/>2、数据分片策略<br/>3、结果聚合技术<br/>4、容错机制设计<br/>5、Map-Reduce实现<br/>6、大数据处理测试 |
|  | **对应代码：** `4-BuildYourAssiant/map-reduce.ipynb` | | **算力消耗：** OpenAI API调用~25-35次（约$0.04-0.06） |
| 实操 | 案例：子图设计与研究助手 | 实操 | 1、子图架构设计<br/>2、模块化Agent开发<br/>3、研究助手案例分析<br/>4、复杂工作流编排<br/>5、研究助手开发实战<br/>6、模块化设计验证 |
|  | **对应代码：** `4-BuildYourAssiant/sub-graph.ipynb`, `research-assistant/` | | **算力消耗：** OpenAI API调用~40-60次（约$0.07-0.10） |
| **第五章：长期记忆系统** | | | |
| 12 | 记忆存储架构 | 实操 | 1、长期记忆系统设计<br/>2、向量数据库集成<br/>3、记忆检索策略<br/>4、记忆更新机制<br/>5、记忆存储实现<br/>6、性能优化调试 |
|  | **对应代码：** `5-LongTermMemroy/memory_store.ipynb` | | **算力消耗：** OpenAI API调用~20-30次（约$0.035-0.05） |
| 13 | 记忆模式与集合 | 实操 | 1、记忆模式设计<br/>2、用户画像构建<br/>3、记忆分类管理<br/>4、隐私保护机制<br/>5、用户画像系统<br/>6、隐私保护验证 |
|  | **对应代码：** `5-LongTermMemroy/memoryschema_collection.ipynb`, `memoryschema_profile.ipynb` | | **算力消耗：** OpenAI API调用~15-25次（约$0.025-0.04） |
| 14 | 记忆Agent整合 | 实操 | 1、记忆Agent架构<br/>2、上下文感知技术<br/>3、个性化交互<br/>4、学习能力实现<br/>5、上下文管理测试<br/>6、学习效果评估 |
|  | **对应代码：** `5-LongTermMemroy/memory_agent.ipynb` | | **算力消耗：** OpenAI API调用~20-30次（约$0.035-0.05） |
| **第六章：Agent评估与监控** | | | |
| 15 | Agent评估体系构建 | | 1、评估在AI产品中的重要性<br/>2、评估指标体系设计<br/>3、自动化vs人工评估<br/>4、评估数据准备策略<br/>5、评估框架搭建<br/>6、评估流程自动化 |
|  | **对应代码：** `06-agent-evaluation/langfuse/大模型评估体系与Langfuse实战指南.md` | | **算力消耗：** 评估API调用~50-100次（约$0.08-0.15） |
| 实操 | 案例：Langfuse集成与追踪 | 实操 | 1、Langfuse平台介绍<br/>2、追踪系统原理<br/>3、多智能体追踪<br/>4、性能监控指标<br/>5、Langfuse配置集成<br/>6、性能数据分析 |
|  | **对应代码：** `06-agent-evaluation/langfuse/01_04_integration_langgraph.ipynb` | | **算力消耗：** OpenAI API调用~30-40次（约$0.05-0.07） |
| 实操 | 案例：质量评估与优化 | 实操 | 1、质量评估方法论<br/>2、A/B测试设计<br/>3、评估结果分析<br/>4、持续优化策略<br/>5、A/B测试执行<br/>6、优化方案实施 |
|  | **对应代码：** `06-agent-evaluation/langfuse/03_evaluation_with_langchain.ipynb` | | **算力消耗：** 评估API调用~40-60次（约$0.07-0.10） |
| **第七章：生产部署与运维** | | | |
| 16 | 容器化部署 | 实操 | 1、Docker容器化原理<br/>2、微服务架构设计<br/>3、环境配置管理<br/>4、服务编排策略<br/>5、Docker镜像构建<br/>6、服务部署测试 |
|  | **对应代码：** `6-Deployment/deployment/docker-compose-example.yml` | | **算力消耗：** 本地Docker部署，无API成本 |
| 17 | Assistant API与连接管理 | 实操 | 1、Assistant API设计<br/>2、连接池管理<br/>3、会话管理机制<br/>4、负载均衡策略<br/>5、Assistant API开发<br/>6、负载测试验证 |
|  | **对应代码：** `6-Deployment/assistant.ipynb`, `connecting.ipynb`, `creating.ipynb` | | **算力消耗：** OpenAI API调用~25-35次（约$0.04-0.06） |
| 实操 | 案例：生产监控与优化 | 实操 | 1、生产环境监控<br/>2、并发处理问题<br/>3、系统健康检查<br/>4、性能优化策略<br/>5、监控系统搭建<br/>6、性能调优验证 |
|  | **对应代码：** `6-Deployment/double-texting.ipynb` | | **算力消耗：** 监控API调用~15-25次（约$0.025-0.04） |

---

## 总体算力消耗估算

### 💰 成本预估（按章节）

| 章节 | 理论视频时长 | 实验时长 | OpenAI API成本 | 其他API成本 | 总成本范围 |
|------|-------------|----------|----------------|------------|-----------|
| 第一章 | 90分钟 | 270分钟 | $0.045-0.095 | $0.01-0.02 | **$0.055-0.115** |
| 第二章 | 115分钟 | 310分钟 | $0.075-0.13 | - | **$0.075-0.13** |
| 第三章 | 100分钟 | 290分钟 | $0.065-0.11 | - | **$0.065-0.11** |
| 第四章 | 110分钟 | 340分钟 | $0.16-0.23 | $0.02-0.05 | **$0.18-0.28** |
| 第五章 | 90分钟 | 270分钟 | $0.095-0.14 | - | **$0.095-0.14** |
| 第六章 | 125分钟 | 330分钟 | $0.2-0.32 | - | **$0.2-0.32** |
| 第七章 | 105分钟 | 310分钟 | $0.09-0.14 | - | **$0.09-0.14** |
| **总计** | **735分钟** | **2120分钟** | **$0.73-1.165** | **$0.03-0.07** | **$0.76-1.235** |

### 📊 资源使用说明

**API调用成本：**
- OpenAI GPT-4o：约$0.005-0.015/1K tokens
- 搜索API（Tavily）：约$0.002/请求
- Langfuse：免费层支持，付费层$0.1/1K traces

**本地资源需求：**
- CPU：中等使用，多核处理器推荐
- 内存：8GB RAM最低，16GB推荐
- 存储：2GB用于代码和数据
- 网络：稳定互联网连接

---

## 学习路径建议

### 🚀 初学者路径（6-8周）
**总学习时间：** 约47小时
**总成本：** $0.4-0.6

1. **第1章**：Agent基础入门（6小时）
2. **第2章**：状态管理与内存系统（7小时）
3. **第3章**：人机交互系统（6.5小时）
4. **第6章**：Agent评估与监控（7.5小时）

### 🎯 进阶开发者路径（8-10周）
**总学习时间：** 约60小时
**总成本：** $0.6-0.9

1. **第1-3章**：基础到中级技能（19.5小时）
2. **第4章**：高级Agent开发（7.5小时）
3. **第5章**：长期记忆系统（6小时）
4. **第6-7章**：评估部署运维（14.5小时）

### 🏆 专家级路径（10-12周）
**总学习时间：** 约78小时
**总成本：** $0.76-1.24

1. 完成所有7个章节
2. 深度实践每个实验
3. 自主项目开发
4. 社区贡献和分享

---

## 课程资源配置

### 📚 必需环境
- **Python 3.11+** 
- **Jupyter Notebook**
- **Docker Desktop**
- **Git**

### 🔑 API密钥要求
- **OpenAI API Key**（必需）
- **Langfuse Keys**（评估章节必需）
- **Tavily API Key**（搜索功能）

### 💾 代码资源
- **Jupyter Notebooks**：21个完整实验
- **LangGraph Studio配置**：可视化调试
- **Docker配置文件**：生产部署
- **评估框架**：Langfuse集成

---

## 学习成果评估

### 📋 技能检查清单

**基础技能（第1-3章）**
- [ ] 能够构建基本的LangGraph应用
- [ ] 掌握状态管理和消息处理
- [ ] 实现人机交互功能
- [ ] 理解Agent工作原理

**进阶技能（第4-5章）**
- [ ] 设计并行和Map-Reduce工作流
- [ ] 构建子图和模块化系统
- [ ] 实现长期记忆功能
- [ ] 优化性能和资源使用

**专业技能（第6-7章）**
- [ ] 建立完整评估体系
- [ ] 集成监控和追踪系统
- [ ] 实现生产部署
- [ ] 掌握运维和优化

### 🎯 项目里程碑

1. **基础项目**：简单聊天机器人（第1章）
2. **中级项目**：带记忆的智能助手（第2-3章）
3. **高级项目**：研究助手系统（第4-5章）
4. **专业项目**：生产级Agent平台（第6-7章）

---

## 技术支持

### 🛠️ 调试工具
- **LangGraph Studio**：图形化调试界面
- **Langfuse Dashboard**：性能监控和追踪
- **Jupyter Debugger**：代码调试
- **Docker Logs**：部署诊断

### 📞 学习支持
- **代码示例**：每个概念都有完整实现
- **错误处理**：常见问题和解决方案
- **最佳实践**：生产环境经验分享
- **社区支持**：技术交流和答疑

---

**准备好开始您的Agent开发专业之旅了吗？** 🚀

> 本课程设计基于真实的生产环境需求，每一行代码都经过实战验证，确保学员能够掌握从原型到生产的完整技能栈。
